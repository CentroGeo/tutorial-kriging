
library(sp)
library(gstat)
library(ggplot2)

## Carga y exploración de datos
?meuse
data("meuse")
class(meuse)
str(meuse)
meuse$logZn <- log10(meuse$zinc)
View(meuse)
## Conversión a datos espaciales
coordinates(meuse)<-c("x","y")
class(meuse)
str(meuse)

# mapeo de datos, primero sólo los puntos
# Para graficar con ggplot, necesitamos regresar los datos a un data.frame
mapdata <- data.frame(meuse)
ggplot(data=mapdata) + geom_point(aes(x,y), color="blue", alpha=3/4)  +
   coord_equal() + theme_bw()

# Luego los puntos pero variando el tamaño de acuerdo a la proporción de Zinc
# con respecto al máximo
ggplot(data=mapdata, aes(x,y)) +
   geom_point(aes(size=4*zinc/max(zinc)), color="blue", alpha=3/4) +
   ggtitle("Zinc Concentration (ppm)") + coord_equal() + theme_bw()

# Ahora vamos a incluir los ríos en la gráfica, primero leemos los datos
data("meuse.riv")
# ¿De qué clase son?
class(meuse.riv)

# Como ggplot sólo sabe trabajar sobre DataFrames, los convertimos: 
meuse.riv.df <- data.frame(meuse.riv)

# Ahora sí podemos graficarlo usando geom_path
# (para unir los puntos en el orden en el que están)
ggplot(data=mapdata,aes(x, y)) +
    geom_point(aes(size=4*zinc/max(zinc)), color="blue", alpha=3/4) +
    geom_path(data=meuse.riv.df, aes(x=X1,y=X2)) +
    ggtitle("Zinc Concentration (ppm)") + coord_equal() + theme_bw()


# dependencia espacial, distancia entre puntos
n <- length(meuse$logZn)
n*(n-1)/2
dim(coordinates(meuse))
coordinates(meuse)[1,]
coordinates(meuse)[2,]
# calcula distancia entre los primeros 2 elementos de meuse
sep <- dist(coordinates(meuse)[1:2,]) 
sep
gamma

#cálculo y gráfica de variograma experimental
exp.variogram <- variogram(logZn~1, meuse, cutoff=1300, width=90)
View(exp.variogram)
ggplot(data = exp.variogram, mapping = aes(x=dist,y=gamma)) +
    geom_point() +
    geom_text(aes(label=np),hjust=0, vjust=0)

# Ahora, en lugar de usar la cantidad de puntos como etiquetas, 
# usemos el tamaño de los puntos para representar la cantidad
ggplot(data = exp.variogram, mapping = aes(x=dist,y=gamma)) +
    geom_point(aes(size=np), color="blue", alpha=3/4)

# Variograma empírico. ¿Qué modelos podemos ajustar?
show.vgms()


# Primero creamos un variograma arbitrario y obtenemos
# sus valores para poder graficarlo
vm <- vgm(psill = 0.13, model = "Sph", range = 850, nugget = 0.01)
max.dist <- max(exp.variogram$dist)
vm.line <- variogramLine(vm, max.dist, n = 200, min =  1.0e-6 * max.dist,
                         dir = c(1,0,0), covariance = FALSE) 
ggplot(data = vm.line, mapping = aes(x=dist,y=gamma)) +
    geom_line() +
    geom_point(data = exp.variogram, mapping = aes(x=dist, y=gamma, size = np))

# Ahora vamos a ajustar un variograma esférico
fitted.vm <- fit.variogram(exp.variogram, vm) #ajuste asistido

#print(plot(exp.variogram, pl=T, model=fitted.vm))
fitted.vm.line <- variogramLine(fitted.vm, max.dist, n = 200, min =  1.0e-6 * max.dist,
                         dir = c(1,0,0), covariance = FALSE) 
ggplot(data = fitted.vm.line, mapping = aes(x=dist,y=gamma)) +
    geom_line() +
    geom_point(data = exp.variogram, mapping = aes(x=dist, y=gamma, size = np))


#carga de malla regular de 40x40 m.
data("meuse.grid")
coordinates(meuse.grid)<- c("x","y")
str(meuse.grid)
gridded(meuse.grid) <- T #especifíca que es una malla regular

#cálculo de KO sobre la malla regular
k40<- krige(logZn~1, locations = meuse, newdata =meuse.grid, model =vmf)
str(k40)
#despliegue del mapa de los valores predichos
print(spplot(k40,"var1.pred",asp=1,col.regions=bpy.colors(64),main="KO predicción,log-ppm Zn"))
#mapa de las varianza de las predicciones
print(spplot(k40, "var1.var",col.regions=cm.colors(64), asp=1,main="KO varianza de la predicción, log-ppm Zn^2")) 
#mapa con el tamaño de los círculos
pts.s <- list("sp.points", meuse, col="white", pch=1, cex=4*meuse$zinc/max(meuse$zinc))
print(spplot(k40,"var1.pred",asp=1, col.regions=bpy.colors(64), main= "KO predicción", sp.layout=list(pts.s)))              
pts<-list("sp.points", meuse, col="black", pch=20)
print(spplot(k40, "var1.var",col.regions=cm.colors(64), asp=1,main="KO varianza de la predicción, log-ppm Zn^2",sp.layout=list(pts))) 

#validación cruzada LOCCV
kcv.ok<- krige.cv(logZn~1, locations = meuse, model=vmf)
summary (kcv.ok)
summary(kcv.ok$residual)
#medida dek RMSE
sqrt(sum(kcv.ok$residual^2)/length(kcv.ok$residual))
